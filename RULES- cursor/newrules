# üÜï NUOVE REGOLE - STUDENT ANALYST

> **‚ö†Ô∏è REGOLE APPRESE DURANTE LO SVILUPPO** | [Componenti Analisi](#componenti-analisi) | [Validazione Dati](#validazione-dati) | [Testing](#testing) | [Documentazione](#documentazione)

---

## üö® REGOLE ANTI-REGRESSIONE E DEPLOY STATICI (2024-06)

### **Static Assets & Vercel - SEMPRE OBBLIGATORIO**

- **Verifica SEMPRE** che la configurazione Vercel (`vercel.json`) abbia la chiave `outputDirectory` corretta (es: `"dist"` per Vite) quando usi build tools che non producono output in `public/`.
- **Testa SEMPRE** la raggiungibilit√† di almeno un file statico di test (es: `/logo-test.txt`, `/lovable-uploads/debug-logo.txt`) dopo ogni deploy.
- **Non dare MAI per scontato** che la presenza dei file in `dist/` o `public/` localmente implichi che saranno serviti da Vercel: controlla sempre la root di deploy e la configurazione.
- **Se un asset non si vede ma la build √® corretta**, controlla subito: outputDirectory, root di progetto su Vercel, e la presenza reale del file via URL pubblico.
- **Se un file statico non viene servito, NON modificare il codice React/JSX**: il problema √® quasi sempre di deploy/config.
- **Quando sostituisci asset binari (es: PNG)**, verifica che siano validi e non corrotti sia localmente che dopo il deploy (apri l'URL diretto!).
- **Documenta sempre** la soluzione definitiva nel repo (README o regole) per evitare ricadute future.

### **UI/UX Component Regression - SEMPRE OBBLIGATORIO**

- **Non sostituire MAI componenti custom (es: Select, Dropdown, DatePicker) con elementi HTML nativi** senza motivazione e test visivo: causa regressioni di stile e UX.
- **Quando modifichi un input o una select, verifica SEMPRE che il look sia coerente con il resto dell'app** (soprattutto dopo merge o refactor).
- **Se usi una libreria UI (Shadcn, Radix, HeadlessUI, ecc.), preferisci SEMPRE i componenti custom rispetto agli elementi nativi** per coerenza visiva e accessibilit√†.
- **Dopo ogni refactor di componenti UI, testa manualmente i flussi principali** e confronta con screenshot precedenti.
- **Aggiungi test visivi o screenshot di riferimento** per i componenti critici (dropdown, sidebar, logo, ecc.).
- **Se noti una regressione, ripristina subito il componente custom** e documenta la causa per evitare errori simili.

---

## üß© COMPONENTI ANALISI

### **Protezione Valori Undefined - SEMPRE OBBLIGATORIA**

**Regola**: Ogni modifica futura ai componenti di analisi deve includere protezione contro valori undefined e validazione dei dati.

**Motivazione**: Evita errori `TypeError: Cannot read properties of undefined (reading 'toFixed')` e crash dell'applicazione.

**Implementazione**:

```typescript
// ‚úÖ CORRETTO - Protezione contro undefined
{metric.label || 'Metrica'}
{metric.value || '0%'}
${ticker.price?.toFixed(2) || '0.00'}
{sharpeRatio?.toFixed(2) || '0.00'}

// ‚ùå SBAGLIATO - Nessuna protezione
{metric.label}
{metric.value}
${ticker.price.toFixed(2)}
{sharpeRatio.toFixed(2)}
```

**Checklist Pre-Commit**:

- [ ] Tutti i valori numerici hanno protezione `?.` o `||`
- [ ] Tutti i valori stringa hanno fallback
- [ ] Tutti i valori array hanno `|| []`
- [ ] Tutti i valori oggetto hanno `|| {}`
- [ ] Testato con dati undefined/null

### **Collegamento Dati Reali - SEMPRE OBBLIGATORIO**

**Regola**: Ogni componente di output deve leggere SOLO da `analysisResults` del context, mai da dati statici o placeholder.

**Motivazione**: Garantisce coerenza dei dati e elimina valori finti che confondono l'utente.

**Implementazione**:

```typescript
// ‚úÖ CORRETTO - Dati reali dal context
const { analysisResults } = useAnalysisContext();
const metrics = analysisResults?.performanceMetrics || [];
const volatility = analysisResults?.volatility;

// ‚ùå SBAGLIATO - Dati statici
const metrics = [
  { label: 'Rendimento Totale', value: '15.25%' },
  { label: 'Rendimento Annuo', value: '12.50%' },
];
```

### **Messaggi Utente Professionali - SEMPRE OBBLIGATORIO**

**Regola**: Ogni stato senza dati deve avere un messaggio chiaro che guidi l'utente.

**Implementazione**:

```typescript
// ‚úÖ CORRETTO - Messaggio chiaro e professionale
{!hasData && (
  <div className="text-center text-muted-foreground py-8">
    <p>Avvia un'analisi per vedere le metriche di performance</p>
    <p className="text-sm">Inserisci i simboli dei titoli e clicca su "Avvia Analisi"</p>
  </div>
)}

// ‚ùå SBAGLIATO - Messaggio generico
{!hasData && <div>Nessun dato</div>}
```

---

## üîí VALIDAZIONE DATI

### **Validazione Context - SEMPRE OBBLIGATORIA**

**Regola**: Validare sempre i dati prima di salvarli nel context per evitare errori runtime.

**Implementazione**:

```typescript
// Validazione risultati prima di salvarli
const validatedResults = {
  ...results,
  performanceMetrics:
    results.performanceMetrics?.map(metric => ({
      label: metric.label || 'Metrica',
      value: metric.value || '0%',
    })) || [],
  volatility: results.volatility
    ? {
        annualizedVolatility: results.volatility.annualizedVolatility || 0,
        sharpeRatio: results.volatility.sharpeRatio || 0,
      }
    : null,
  correlation: results.correlation
    ? {
        correlationMatrix: results.correlation.correlationMatrix || {
          symbols: [],
          matrix: [],
        },
        diversificationIndex: results.correlation.diversificationIndex || 0,
        averageCorrelation: results.correlation.averageCorrelation || 0,
      }
    : null,
};
```

### **TypeScript Interfaces - SEMPRE OBBLIGATORIO**

**Regola**: Definire sempre interfacce TypeScript per tutti i dati e props.

**Implementazione**:

```typescript
// ‚úÖ CORRETTO - Interfacce definite
interface PerformanceMetric {
  label: string;
  value: string;
  description?: string;
}

interface VolatilityData {
  annualizedVolatility: number;
  sharpeRatio: number;
}

interface PerformanceMetricsProps {
  data?: PerformanceMetric[];
  onTheoryClick?: () => void;
  className?: string;
}

// ‚ùå SBAGLIATO - Nessuna interfaccia
const PerformanceMetrics = (props: any) => {
```

---

## üö´ CHIAMATE MULTIPLE

### **Protezione API Calls - SEMPRE OBBLIGATORIA**

**Regola**: Prevenire sempre chiamate API multiple con flag di stato non reattivo.

**Implementazione**:

```typescript
const isAnalysisRunning = useRef(false);

const startAnalysis = async () => {
  if (isAnalysisRunning.current) {
    console.log('üö´ Analisi gi√† in corso, ignoro chiamata multipla');
    return;
  }

  isAnalysisRunning.current = true;
  try {
    // ... logica analisi
  } finally {
    isAnalysisRunning.current = false;
  }
};
```

---

## üß™ TESTING

### **Test E2E - SEMPRE OBBLIGATORIO**

**Regola**: Implementare test E2E per tutti i componenti di output e flussi critici.

**Implementazione**:

```typescript
// Test per componenti di output
test.describe('Output Components E2E Tests', () => {
  test('should show no data message when no analysis is performed', async ({
    page,
  }) => {
    await expect(
      page.locator(
        "text=Avvia un'analisi per vedere le metriche di performance"
      )
    ).toBeVisible();
  });

  test('should display performance metrics after analysis', async ({
    page,
  }) => {
    await page.fill('[data-testid="ticker-input"]', 'AAPL,GOOGL');
    await page.click('[data-testid="start-analysis-button"]');
    await page.waitForSelector('[data-testid="performance-metrics"]', {
      timeout: 30000,
    });
    await expect(
      page.locator('[data-testid="performance-metrics"]')
    ).toBeVisible();
  });
});
```

**Coverage Minimo**:

- ‚úÖ **Rendering senza dati** - Verifica messaggi "no data"
- ‚úÖ **Rendering con dati reali** - Verifica visualizzazione corretta
- ‚úÖ **Interazioni utente** - Verifica bottoni teoria e aggiorna
- ‚úÖ **Integrazione componenti** - Verifica sincronizzazione
- ‚úÖ **Gestione errori** - Verifica robustezza con input invalidi
- ‚úÖ **Accessibilit√†** - Verifica struttura e navigazione

### **Test Unitari - SEMPRE OBBLIGATORIO**

**Regola**: Implementare test unitari per ogni componente con coverage >80%.

**Implementazione**:

```typescript
describe('PerformanceMetrics', () => {
  it('should render with no data message when no context is provided', () => {
    render(<PerformanceMetrics />);
    expect(screen.getByText('Avvia un\'analisi per vedere le metriche di performance')).toBeInTheDocument();
  });

  it('should render with real data when provided', () => {
    const mockData = [{ label: 'Rendimento Totale', value: '15.25%' }];
    render(<PerformanceMetrics data={mockData} />);
    expect(screen.getByText('Rendimento Totale')).toBeInTheDocument();
  });
});
```

### **Test Setup - SEMPRE OBBLIGATORIO**

**Regola**: Configurare correttamente Jest e Playwright per evitare errori di setup.

**Implementazione**:

```javascript
// jest.config.js
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'jsdom',
  setupFilesAfterEnv: ['<rootDir>/tests/setup.ts'],
  moduleNameMapper: {
    '^@/(.*)$': '<rootDir>/src/$1',
  },
  collectCoverageFrom: ['src/**/*.{ts,tsx}'],
  coverageThreshold: {
    global: { branches: 80, functions: 80, lines: 80, statements: 80 },
  },
};
```

---

## üìö DOCUMENTAZIONE

### **Documentazione Refactoring - SEMPRE OBBLIGATORIA**

**Regola**: Documentare sempre il refactoring con esempi prima/dopo e best practice.

**Implementazione**:

````markdown
# Guida al Refactoring - Componenti di Output

## Prima del Refactoring

```typescript
// ‚ùå DATI STATICI - SBAGLIATO
const metrics = [{ label: 'Rendimento Totale', value: '15.25%' }];
```
````

## Dopo il Refactoring

```typescript
// ‚úÖ DATI REALI DAL CONTEXT - CORRETTO
const { analysisResults } = useAnalysisContext();
const metrics = analysisResults?.performanceMetrics || [];
```

## Best Practice Implementate

- ‚úÖ Protezione valori undefined
- ‚úÖ Fallback robusti
- ‚úÖ Messaggi utente chiari
- ‚úÖ TypeScript interfaces

````

### **Regole Anti-Regressione - SEMPRE OBBLIGATORIO**

**Regola**: Documentare regole anti-regressione per evitare ricadute future.

**Implementazione**:

```markdown
## üö® REGOLE ANTI-REGRESSIONE

### **Protezione Valori Undefined**
- Ogni valore numerico deve avere protezione `?.` o `||`
- Ogni valore stringa deve avere fallback
- Ogni valore array deve avere `|| []`
- Ogni valore oggetto deve avere `|| {}`

### **Validazione Context**
- Validare sempre i dati prima di salvarli nel context
- Implementare fallback per ogni campo
- Testare con dati edge case

### **Prevenzione Chiamate Multiple**
- Usare flag di stato non reattivo
- Prevenire chiamate API multiple
- Gestire stati di loading correttamente
````

---

## üéØ OPERATIONAL PROMPT

### **Prompt per Refactoring Completo - SEMPRE OBBLIGATORIO**

**Regola**: Usare sempre un prompt operativo strutturato per refactoring complessi.

**Implementazione**:

```markdown
# PROMPT OPERATIVO PER COLLEGAMENTO STEP ANALISI DATI

## REGOLE CRITICHE DA RISPETTARE

- Non fare mai supposizioni su nomi di variabili, funzioni o file
- Leggi sempre il file target prima di modificare
- Ogni componente di output deve leggere solo da analysisResults del context
- Non usare mai dati statici, random, di copertina o placeholder
- Proteggi ogni valore numerico con fallback (?. o ||)
- Valida sempre i dati prima di salvarli nel context
- Previeni chiamate API multiple con flag di stato non reattivo

## PERCORSO OPERATIVO

1. **Step 1: Mappatura** - Mappa tutti i componenti di output
2. **Step 2: Refactor Componenti** - Refactorizza ogni componente
3. **Step 3: Azioni e Sincronizzazione** - Collega bottoni e logica
4. **Step 4: Test e Documentazione** - Aggiungi test e documenta
```

---

## üîß TROUBLESHOOTING

### **Errori Comuni - SEMPRE DOCUMENTARE**

**Regola**: Documentare sempre le soluzioni per errori comuni.

**Implementazione**:

````markdown
## üîß Troubleshooting Comune

### **Errore: "Cannot read properties of undefined"**

```typescript
// ‚úÖ SOLUZIONE
const value = data?.price?.toFixed(2) || '0.00';
```
````

### **Errore: "Component not rendering"**

```typescript
// ‚úÖ SOLUZIONE
{(data || []).map(item => <div>{item.name || 'N/A'}</div>)}
```

### **Errore: "Multiple API calls"**

```typescript
// ‚úÖ SOLUZIONE
const isRunning = useRef(false);
if (isRunning.current) return;
isRunning.current = true;
// ... logica
isRunning.current = false;
```

```

---

## üéØ REGOLE FINALI

1. **Ogni componente di analisi DEVE avere protezione contro undefined**
2. **Ogni context DEVE validare i dati prima di salvarli**
3. **Ogni funzione async DEVE prevenire chiamate multiple**
4. **Ogni valore numerico DEVE avere fallback per toFixed()**
5. **Ogni modifica DEVE essere testata con dati edge case**
6. **Ogni refactoring DEVE essere documentato con esempi**
7. **Ogni componente DEVE avere test E2E e unitari**
8. **Ogni errore comune DEVE avere soluzione documentata**
9. **Ogni prompt operativo DEVE essere strutturato e completo**
10. **Ogni regola anti-regressione DEVE essere implementata**

**‚ö†Ô∏è IMPORTANTE**: Queste regole sono critiche per la stabilit√† dell'applicazione. Non ignorare mai.

---

## üìä METRICHE DI QUALIT√Ä

### **Checklist Pre-Commit OBBLIGATORIA**

- [ ] Tutti i valori numerici hanno protezione `?.` o `||`
- [ ] Tutti i valori stringa hanno fallback
- [ ] Tutti i valori array hanno `|| []`
- [ ] Tutti i valori oggetto hanno `|| {}`
- [ ] Testato con dati undefined/null
- [ ] TypeScript check passa (`tsc --noEmit`)
- [ ] Test E2E passano
- [ ] Test unitari passano (se implementati)
- [ ] Commit message convenzionale
- [ ] Documentazione aggiornata
- [ ] Regole anti-regressione rispettate

### **Metriche Minime**

- **Coverage Test**: >80% per componenti critici
- **Test E2E**: 1 test per ogni componente di output
- **TypeScript**: 0 errori di tipo
- **Fallback**: 100% dei valori protetti
- **Documentazione**: 1 guida per ogni refactoring complesso
```
